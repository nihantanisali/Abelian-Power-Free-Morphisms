#!/usr/bin/env python
############################################
# Theorem 5.1
############################################
import numpy as np

from typing import List, Tuple, Dict

from concurrent.futures import ProcessPoolExecutor
import multiprocessing


h = ['00001', '010101']
m=len(h)
N  = max(len(x) for x in h )

# alphabet is \Sigma={str(0),...,str(n-1)}, and we use str(n) to stand for the empty word.

def parikh(word):
    return np.array([word.count("0"), word.count("1")])

def applyh(w):
    return ''.join(h[int(ch)] for ch in w)

def applyh_iterative(w,k):
    for i in range(k):
        w=applyh(w)
    return w

def splits(h,m):
    S = []
    for i in range(m + 1):
        S.append([])
    S[m].append([m, parikh(''), parikh('')])
    for A in range(m):
        w = h[A]
        for i in range(len(w) + 1):
            S[m].append([A, parikh(w[:i]), parikh(w[i:])])
        for i in range(len(w)):
            S[int(w[i])].append([A, parikh(w[:i]), parikh(w[i + 1:])])    
    return S
S= splits(h,m)

#Matrix multiplication ----> Con function
def Con( x,y ):
    num1 =  x - y
    num2 = -1*x + 4*y
    if num1 % 3 == 0 and num2 % 9 == 0:
        return [num1 // 3, num2 // 9]
    return None

        
    
def parents(t):  # Finds the parents of a template t
    par=[]
    for A in S[t[0]]:
        for B in S[t[1]]:
          
            for C in S[t[2]]:
                s1p2 = A[2]+B[1]
                s2p3 = B[2]+C[1]
                v1 = np.array([t[6],t[7]])-s2p3+s1p2
                
                C1= Con(v1[0], v1[1])
                if C1 !=None :
                    for D in S[t[3]]:
                        s3p4 = C[2]+D[1]
                        v2 =np.array([t[8],t[9]])-s3p4+s2p3
                        C2 = Con(v2[0], v2[1])
                        if C2 != None:
                            for E in S[t[4]]:
                                s4p5 = D[2]+E[1]
                                v3 = np.array([t[10],t[11]])-s4p5+s3p4
                                C3= Con(v3[0], v3[1])
                                if C3 != None:
                                    for F in S[t[5]]:
                                        s5p6 = E[2]+F[1]
                                        v4 = np.array([t[12],t[13]])-s5p6+s4p5
                                        C4= Con(v4[0], v4[1])
                                        
                                        if C4 != None:
                                            par.append(( [A[0],B[0],C[0],D[0],E[0],F[0],      
                                                          C1[0],C1[1],    C2[0],C2[1],   C3[0],C3[1],  
                                                          C4[0],C4[1]] ))
                                                                                                                                               
    par=set(map(tuple,par))
    par=list(par)
    return par


t=   [m,m,m,m,m,m,      0, 0,   0, 0,    0, 0,    0, 0]# The template for Abelian 8-powers

def ancestors(T):  # closure of parents
    level = 0  # how many iterations of parents to get the closure
    V = set(map(tuple, T))  # current list of ancestors
    U = list(T)  # new ancestors
    while len(U) > 0:
        newtem = []
        newTemplates = []
        # Parallel processing of U
        with ProcessPoolExecutor(max_workers=multiprocessing.cpu_count()) as executor:
            chunksize = max(1, len(U) // multiprocessing.cpu_count())
            results = executor.map(parents, U, chunksize=chunksize)
        for result in results:
            newtem.extend(result)
        newtem=set(map(tuple, newtem))
        newtem=newtem.difference(V)
        V = V.union(newtem)
        newtem=list(newtem)
        U = newtem
        if len(U) > 0: 
            level = level + 1
            print('at level',level,'there are',len(U),'new templates.')
    return [V, level]

def split_template(template: List[int]) -> Tuple[List[int], List[Tuple[int, int]]]:
    if len(template) != 14:
        raise ValueError("Templates consist of 14 numbers: 6 a_i + 8 d_ij.")
    a = template[:6]
    d = template[6:]
    d_pairs = [(d[2*i], d[2*i+1]) for i in range(4)]
    return a, d_pairs

def cumulative_deltas(d_pairs: List[Tuple[int, int]]) -> List[int]:
    cum = [0]
    s = 0
    for i in range(4):
        s += d_pairs[i][0] + d_pairs[i][1]
        cum.append(s)
    return cum         # 14 integer values

def search_bound(N,K,Q):
    delta_set=[]
    for t in Q:
        a,d=split_template(t)
        cum= cumulative_deltas(d)
        delta=max(cum)-min(cum)
        delta_set.append(delta)
    delta=max(delta_set) #maximum difference of |X_i|-|X_j|
    return N+K-1 +(K-1 )*(N-2+delta)


def avoids_abelian_k_power(sequence: str, k: int) -> bool:
    n = len(sequence)
    for block_len in range(1, n // k + 1):
        for start in range(n - block_len * k + 1):
            blocks = [sequence[start + j * block_len : start + (j + 1) * block_len] for j in range(k)]
            if all(sorted(blocks[0]) == sorted(b) for b in blocks):
                return False
    return True

print('==============================================================================')
print('======================== First Part  =========================================')
print('==============================================================================\n')
print('We compute the number of ancestors of T5:')
Q=ancestors([t])
Search_bound=search_bound(6,5,list(Q[0]))
word=applyh_iterative('0',5)
word_avoid_5_power= avoids_abelian_k_power(word,5)
print('The total number of ancestors is ',len(Q[0]),', found in',Q[1],'generations.\n')
print('The search bound is computed:',search_bound(6,5,list(Q[0])) ,'.\n')
print('==============================================================================')
print('======================== Second Part  ========================================')
print('==============================================================================\n')
print('Instead of checking if the templates are realized, we can check whether h^5 is abelian 5-power free.')
if word_avoid_5_power:
    print('h^5(a), and hence h^Ï‰(a), is abelian 5 power free')

